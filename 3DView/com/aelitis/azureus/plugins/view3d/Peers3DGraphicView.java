/* * Created on 30 mai 2005 * Created by Olivier Goussard *  * Copyright (C) 2005 Aelitis SARL, All rights Reserved */package com.aelitis.azureus.plugins.view3d;import java.awt.Toolkit;import java.nio.*;import java.util.ArrayList;import java.util.Arrays;import java.util.Comparator;import java.util.HashMap;import java.util.LinkedList;import java.util.List;import java.util.Map;import java.util.Timer;import java.util.TimerTask;import org.eclipse.swt.SWT;import org.eclipse.swt.events.ControlAdapter;import org.eclipse.swt.events.ControlEvent;import org.eclipse.swt.events.MouseAdapter;import org.eclipse.swt.events.MouseEvent;import org.eclipse.swt.graphics.Rectangle;import org.eclipse.swt.layout.FillLayout;import org.eclipse.swt.opengl.GLCanvas;import org.eclipse.swt.opengl.GLData;import org.lwjgl.opengl.*;import org.lwjgl.util.glu.*;import org.lwjgl.BufferUtils;import org.lwjgl.LWJGLException;import org.eclipse.swt.widgets.Composite;import org.eclipse.swt.widgets.Display;import org.eclipse.swt.widgets.Event;import org.eclipse.swt.widgets.Listener;import org.eclipse.swt.widgets.Shell;import org.gudy.azureus2.plugins.PluginInterface;import org.gudy.azureus2.plugins.download.Download;import org.gudy.azureus2.plugins.utils.ByteArrayWrapper;import org.gudy.azureus2.plugins.utils.Utilities;import org.gudy.azureus2.plugins.network.Connection;import org.gudy.azureus2.plugins.peers.Peer;import org.gudy.azureus2.plugins.peers.PeerManager;import com.aelitis.azureus.core.AzureusCore;import com.aelitis.azureus.core.AzureusCoreFactory;class Peers3DGraphicView {	private static boolean TESTING  = false;		private Timer timer;	private TimerTask timerTask;	private PluginInterface pluginInterface;	private HashMap parameters;	private Utilities utilities;	private Download download;	private PeerComparator peerComparator;	// UI Stuff	private Composite composite;	private Display display;	private Shell shell;	// OpenGL Stuff	private GLCanvas glCanvas;//	private GLContext context;	private Cylinder cylinder;	private Disk disk;	private int sleep = 20;	private boolean mouseDown;	private boolean mouseDown2;	private int mouseDownX;	private int mouseDownY;	private float viewAngle = 45.0f;	private float[] bgColor = { 0.078f, 0.176f, 0.306f, 1.0f };	private float[] lightPosition = { 30.0f, -80.0f, 50.0f, 1.0f };	private float[][] materialShininess = { { 50.0f }, // blue			{ 50.0f }, // grey			{ 50.0f }, // red			{ 50.0f } // green	};	private float[][] colorValues = { // blue	{ 1.0f, 1.0f, 1.0f, 1.0f }, // light diffuse			{ 1.0f, 1.0f, 1.0f, 1.0f }, // light ambient			{ 1.0f, 1.0f, 1.0f, 1.0f }, // light specular			{ 0.5f, 0.5f, 0.5f, 0.8f }, // light main ambient			{ 0.0f, 0.0f, 1.0f, 0.6f }, // material diffuse			{ 0.3f, 0.3f, 0.6f, 0.8f }, // material ambient			{ 0.9f, 0.9f, 1.0f, 0.8f } // material specular	};	private float[][] colorValues2 = { // grey	{ 0.5f, 0.5f, 0.5f, 0.3f }, // light diffuse			{ 0.8f, 0.8f, 0.8f, 0.3f }, // light ambient			{ 0.9f, 0.9f, 0.9f, 0.3f }, // light specular			{ 0.5f, 0.5f, 0.5f, 0.7f }, // light main ambient			{ 0.7f, 0.7f, 0.7f, 0.3f }, // material diffuse			{ 0.6f, 0.6f, 0.6f, 0.2f }, // material ambient			{ 0.9f, 0.9f, 0.9f, 0.2f } // material specular	};	private float[][] colorValuesSend = { // red	{ 1.0f, 1.0f, 1.0f, 1.0f }, // light diffuse			{ 1.0f, 1.0f, 1.0f, 1.0f }, // light ambient			{ 1.0f, 1.0f, 1.0f, 1.0f }, // light specular			{ 0.5f, 0.5f, 0.5f, 0.8f }, // light main ambient			{ 0.9f, 0.3f, 0.3f, 0.9f }, // material diffuse			{ 0.6f, 0.3f, 0.3f, 0.9f }, // material ambient			{ 1.0f, 0.9f, 0.9f, 0.8f } // material specular	};	private float[][] colorValuesSeed = { // green	{ 1.0f, 1.0f, 1.0f, 1.0f }, // light diffuse			{ 1.0f, 1.0f, 1.0f, 1.0f }, // light ambient			{ 1.0f, 1.0f, 1.0f, 1.0f }, // light specular			{ 0.5f, 0.5f, 0.5f, 0.5f }, // light main ambient			{ 0.3f, 0.9f, 0.4f, 0.8f }, // material diffuse			{ 0.3f, 0.6f, 0.3f, 0.9f }, // material ambient			{ 0.9f, 1.0f, 0.9f, 0.7f } // material specular	};	private float[][][] colorValuesTab = { colorValues, colorValues2,			colorValuesSend, colorValuesSeed };		private FloatBuffer fB[][] = {{	allocFloats(colorValuesTab[0][0]),									allocFloats(colorValuesTab[0][1]),									allocFloats(colorValuesTab[0][2]),									allocFloats(colorValuesTab[0][3]),									allocFloats(colorValuesTab[0][4]),									allocFloats(colorValuesTab[0][5]),									allocFloats(colorValuesTab[0][6])	},								{	allocFloats(colorValuesTab[1][0]),									allocFloats(colorValuesTab[1][1]),									allocFloats(colorValuesTab[1][2]),									allocFloats(colorValuesTab[1][3]),									allocFloats(colorValuesTab[1][4]),									allocFloats(colorValuesTab[1][5]),									allocFloats(colorValuesTab[1][6])	},								{	allocFloats(colorValuesTab[2][0]),									allocFloats(colorValuesTab[2][1]),									allocFloats(colorValuesTab[2][2]),									allocFloats(colorValuesTab[2][3]),									allocFloats(colorValuesTab[2][4]),									allocFloats(colorValuesTab[2][5]),									allocFloats(colorValuesTab[2][6])	},								{	allocFloats(colorValuesTab[3][0]),									allocFloats(colorValuesTab[3][1]),									allocFloats(colorValuesTab[3][2]),									allocFloats(colorValuesTab[3][3]),									allocFloats(colorValuesTab[3][4]),									allocFloats(colorValuesTab[3][5]),									allocFloats(colorValuesTab[3][6])}								};		public static final int SIZE_FLOAT = 4;	private Quadric quadratic;	private float rotY = 0.0f;	private float rotSteps[] = { 0.0f, 0.005f, 0.015f, 0.05f };	private int rotStep = 2; // first is rotSteps[1]	private float rotYStep = rotSteps[1];	private float alphadeg = -60.0f;	private float yPos = 0.0f, xPos = 0.0f, zPos = -10.0f;	private int nbPeers;	private int widthCompo;	private int heightCompo;		private float radius;	private float theta;	private float peerRadius;		private float centerRadius;	// Position state class and variable	private class PeerState {		float theta;		int percentDone;	}	private HashMap peerStates = new HashMap();	// Percent drawn	private class PeerDisplay {		int percentDisplayed;	}	private HashMap peerDisplayed = new HashMap();	// Comparator Class	// Note: this comparator imposes orderings that are inconsistent with	// equals.	class PeerComparator implements Comparator {		public int compare(Object arg0, Object arg1) {			Peer peer0 = (Peer) arg0;			Peer peer1 = (Peer) arg1;			int percent0 = peer0.getPercentDoneInThousandNotation();			int percent1 = peer1.getPercentDoneInThousandNotation();			return percent0 - percent1;		}	}		/*	 * Plugin Interface	 * Composite	 * User Parameters:	 * 	0: launch on start	: String "0" "1"	 * 	1: rotation speed	: String "0" "1" "2" "3"	 */	public Peers3DGraphicView(			PluginInterface plugin_interface,			Composite _composite,			HashMap _parameters) {		this.pluginInterface = plugin_interface;		this.utilities = pluginInterface.getUtilities();		this.parameters = _parameters;		this.download = null;		this.peerComparator = new PeerComparator();		this.composite = _composite;		initialize(composite);	}	public void delete() {		dispose();	}	private void createOpenGLContext() {		setCurrent();		setupViewingArea();	}	private void initialize(Composite composite) {				display = composite.getDisplay();//		shell = new Shell(display);//		shell.setLayout(new FillLayout());//		Composite comp = new Composite(shell, SWT.NONE);//		comp.setLayout(new FillLayout());		composite.setLayout(new FillLayout());		GLData data = new GLData ();		data.doubleBuffer = true;		data.accumAlphaSize = 8; 		data.accumBlueSize = 8;		data.accumGreenSize = 8;		data.accumRedSize = 8;				glCanvas = new GLCanvas(composite, SWT.NONE, data);		glCanvas.setCurrent();		try {        	GLContext.useContext(glCanvas);        } catch(LWJGLException e) {         	e.printStackTrace();         }				glCanvas.addControlListener(new ControlAdapter() {			public void controlResized(ControlEvent arg0) {				Rectangle size = glCanvas.getClientArea();				widthCompo = size.width;				heightCompo = size.height;				setupViewingArea();			}		});		// create the OpenGL Screen and controls		createOpenGLContext();		init();	}	private void init() {		GL11.glClearColor(bgColor[0], bgColor[1], bgColor[2], bgColor[3]);		setColorValues(0);		quadratic = new Quadric();		quadratic.setNormals(GLU.GLU_SMOOTH);		quadratic.setDrawStyle(GLU.GLU_FILL);		GL11.glLineWidth(1);		GL11.glHint(GL11.GL_LINE_SMOOTH_HINT, GL11.GL_NICEST);		GL11.glEnable(GL11.GL_LINE_SMOOTH);		GL11.glEnable(GL11.GL_BLEND);		GL11.glHint(GL11.GL_PERSPECTIVE_CORRECTION_HINT, GL11.GL_NICEST);		GL11.glBlendFunc(GL11.GL_SRC_ALPHA, GL11.GL_ONE_MINUS_SRC_ALPHA);		GL11.glPointSize(1.0f);		GL11.glEnable(GL11.GL_LIGHTING);		GL11.glEnable(GL11.GL_LIGHT0);		GL11.glEnable(GL11.GL_DEPTH_TEST);		// GL.glColor4f(1.0f, 1.0f, 1.0f, 0.5f); // Full Brightness. 50% Alpha		// (new		// )		//		shell.setText("3D View");//		shell.setSize(640, 480);//		shell.open();				rotStep = Integer.parseInt((String)parameters.get(new Integer(1)));		rotYStep = rotSteps[rotStep];				glCanvas.addMouseListener(new MouseAdapter() {			public void mouseUp(MouseEvent e) {				mouseDown = false;				mouseDown2 = false;			}			public void mouseDoubleClick(MouseEvent e) {				rotStep++;				if (rotStep >= rotSteps.length)					rotStep = 0;				rotYStep = rotSteps[rotStep];			}		});		glCanvas.addListener(SWT.MouseDown, new Listener() {			public void handleEvent(Event e) {				e.y = glCanvas.getBounds().height - e.y;				if (e.button == 1) {					mouseDown = true;					mouseDownX = e.x;					mouseDownY = e.y;				}				if (e.button == 3) {					mouseDown2 = true;					mouseDownX = e.x;					mouseDownY = e.y;				}			}		});		glCanvas.addListener(SWT.MouseMove, new Listener() {			public void handleEvent(Event e) {				if (mouseDown || mouseDown2) {					e.y = glCanvas.getBounds().height - e.y;					int deltaX = mouseDownX - e.x;					int deltaY = mouseDownY - e.y;					mouseDownX = e.x;					mouseDownY = e.y;					if (deltaY != 0 && mouseDown) {						alphadeg += (float) deltaY / 4.0f;					}					if (deltaY != 0 && mouseDown2) {						viewAngle += (float) deltaY / 4.0f;						setupViewingArea();					}					if (deltaX != 0 && mouseDown) {						rotY -= (float) (deltaX / 360.0f);					}				}			}		});//		final Runnable runnable = new Runnable() {		glCanvas.getDisplay().asyncExec(new Runnable() {			public void run() {				if (glCanvas.isDisposed())					return;				glCanvas.setCurrent();				try {		        	GLContext.useContext(glCanvas);		        } catch(LWJGLException e) { 		        	e.printStackTrace(); 		        }				display();				//display.timerExec(sleep, this);				glCanvas.getDisplay().timerExec(sleep, this);//				glCanvas.getDisplay().asyncExec(this);				//timer.purge();				//new Timer(true).schedule(timerTask, 300);			}		});//		timerTask = new TimerTask() {//		//			public void run() {//				glCanvas.getDisplay().asyncExec(runnable);//				//timer = new Timer(true);//				//			}//		//		};//		timer = new Timer(true);//		timer.schedule(timerTask, 300,sleep);//		runnable.run();//		while (!composite.isDisposed()) {//			if (!glCanvas.getDisplay().readAndDispatch())//				glCanvas.getDisplay().sleep();//		}//		glCanvas.getDisplay().dispose();	}	private void display() {		renderScene();		swap();	}	private void dispose() {		peerStates.clear();		peerDisplayed.clear();//		if(glCanvas != null || glCanvas.isDisposed())//			glCanvas.dispose();		GLContext.unloadOpenGLLibrary();		//display.dispose();		composite.dispose();				//context.dispose();	}	private void drawCylinder(float R, float H, int completion, int color) {		float height = H * completion / 100;		int _color = color;		if (completion == 0) {			setColorValues(1);			disk = new Disk();			disk.draw(0.0f, R, 32, 1);			cylinder = new Cylinder();			cylinder.draw( R, R, H, 32, 1);			GL11.glTranslatef(0, 0, H);			disk = new Disk();			disk.draw( 0.0f, R, 32, 1);		} else {			if (completion == 100) {				if(color == 1){					_color = 1;				} else {					_color = 3;				}			} else if (completion > 100) {				completion = 100;			}			setColorValues(_color);			disk = new Disk();			disk.draw(0.0f, R, 32, 1);			cylinder = new Cylinder();			cylinder.draw( R, R, height, 32, 1);			GL11.glTranslatef(0, 0, height);			disk = new Disk();			disk.draw(0.0f, R, 32, 1);			setColorValues(1);						cylinder = new Cylinder();			cylinder.draw( R, R, H - height, 32, 1);			GL11.glTranslatef(0, 0, H - height);			// GLU.gluDisk(quadratic, 0.0d, R, 16, 1);		}	}	private void drawPacket(int color, float w) {		drawCylinder(w, 5*w, 101, color);		disk = new Disk();		disk.draw( 0.0f, w, 16, 1);	}	private void setCurrent() {		//context.setCurrent();	}	private void setupViewingArea() {		/**///		 Rectangle rect = glCanvas.getBounds();//		 //		 int width = rect.width;//		 //		 int height = rect.height;		 /**/		int height = heightCompo;		int width = widthCompo;		height = Math.max(height, 1);				glCanvas.setCurrent();		try {        	GLContext.useContext(glCanvas);        } catch(LWJGLException e) {         	e.printStackTrace();         }		GL11.glViewport(0, 0, width, height);		GL11.glMatrixMode(GL11.GL_PROJECTION); // select the projection matrix		GL11.glLoadIdentity(); // reset the projection matrix		float fAspect = (float) width / (float) height;		GLU.gluPerspective(viewAngle, fAspect, 0.5f, 100.0f);		GL11.glMatrixMode(GL11.GL_MODELVIEW); // select the modelview matrix		GL11.glLoadIdentity();	}	private int[]	getViewport()	{		IntBuffer viewport = BufferUtils.createIntBuffer(16);		GL11.glGetInteger(GL11.GL_VIEWPORT, viewport);		int[] result = new int[4];		viewport.position( 0 );		viewport.get( result );		return( result );	}		static double[][] jits4 = {{0.375, 0.25}, {0.125, 0.75}, {0.875, 0.25}, {0.625, 0.75}};	static double[][] jits8 = {{0.5625, 0.4375}, {0.0625, 0.9375}, {0.3125, 0.6875}, {0.6875, 0.8125}, {0.8125, 0.1875}, {0.9375, 0.5625}, {0.4375, 0.0625}, {0.1875, 0.3125}};		private void 	accFrustum(		double left, double right, double bottom,		double top, double near, double far, double pixdx, 		double pixdy, double eyedx, double eyedy, 		double focus )	{		double xwsize, ywsize; 		double dx, dy;		int[] viewport = getViewport();		xwsize = right - left;		ywsize = top - bottom;		dx = -(pixdx*xwsize/(double) viewport[2] + 				eyedx*near/focus);		dy = -(pixdy*ywsize/(double) viewport[3] + 				eyedy*near/focus);		GL11.glMatrixMode(GL11.GL_PROJECTION);		GL11.glLoadIdentity();		GL11.glFrustum (left + dx, right + dx, bottom + dy, top + dy, 				near, far);		GL11.glMatrixMode(GL11.GL_MODELVIEW);		GL11.glLoadIdentity();		GL11.glTranslated (-eyedx, -eyedy, 0.0);	}	private void 	accPerspective(		double fovy, double aspect, 		double near, double far, double pixdx, double pixdy, 		double eyedx, double eyedy, double focus)	{		double fov2,left,right,bottom,top;		fov2 = ((fovy*Math.PI) / 180.0) / 2.0;		top = near / (Math.cos(fov2) / Math.sin(fov2));		bottom = -top;		right = top * aspect;		left = -right;		accFrustum (left, right, bottom, top, near, far, pixdx, pixdy, eyedx, eyedy, focus);	}		private void renderScene() {		int ACSIZE = 4;		//org.lwjgl.opengl.Display.sync( 30 );		int[] viewport = getViewport();		GL11.glClear(GL11.GL_ACCUM_BUFFER_BIT);				List<Object[]> objects = computeScene();				for (int jitter = 0; jitter < ACSIZE; jitter++) {			GL11.glClear(GL11.GL_COLOR_BUFFER_BIT | GL11.GL_DEPTH_BUFFER_BIT);	      			double jit_x = jits4[jitter][0];			double jit_y = jits4[jitter][1];					accPerspective (50.0, (double) viewport[2]/(double) viewport[3], 					1.0, 15.0, jit_x, jit_y, 0.0, 0.0, 1.0);	    				renderSceneSupport( objects );		   			GL11.glAccum(GL11.GL_ACCUM, 1.0f/ACSIZE);		}			   GL11.glAccum( GL11.GL_RETURN, 1.0f);	   GL11.glFlush();	   	   // Toolkit.getDefaultToolkit().sync();	}			private List<Object[]>	computeScene()	{		List<Object[]>	objects = new ArrayList<Object[]>(200);		if ( TESTING ){						objects.add( new Object[]{ 0.3f });						return( objects );		}				Peer[] peers;		Peer[] sortedPeers;		if (download == null)			return( objects );		PeerManager pm = download.getPeerManager();		if (pm == null)			return( objects );		peers = pm.getPeers();		List connectedPeers = new ArrayList();		for (int i = 0; i < peers.length; i++) {			if ( peers[i].getConnection() != null && peers[i].getState() == Peer.TRANSFERING )				connectedPeers.add(peers[i]);		}		sortedPeers = (Peer[]) connectedPeers.toArray(new Peer[connectedPeers				.size()]);		Arrays.sort(sortedPeers, peerComparator);		nbPeers = sortedPeers.length;		radius = 3.5f;				peerRadius = 6.0f / nbPeers;		if (peerRadius > 0.2f)			peerRadius = 0.2f;				centerRadius = peerRadius * 2;				if (centerRadius < 0.3f)			centerRadius = 0.3f;				if (peers.length == 0){			objects.add( new Object[]{ centerRadius });			return( objects );		}		boolean notDone = true;		int completion;		int startPeer = 0;		float minAngle = (float) (2 * Math.PI);		while (rotY > Math.PI) {			rotY -= 2 * Math.PI;		}		while (rotY < -Math.PI) {			rotY += 2 * Math.PI;		}		while (alphadeg > 360.0f) {			alphadeg -= 360.0f;		}		while (alphadeg < 0.0f) {			alphadeg += 360.0f;		}		boolean invertedSwarm = false;		if (alphadeg < 180.0f) {			invertedSwarm = true;		}		for (int i = 0; i < nbPeers; i++) {			float angle = (float) (2 * i * Math.PI / nbPeers + rotY);			if (angle < 0)				angle = -angle;			if (angle > 2 * Math.PI)				angle -= 2 * Math.PI;			if (angle < minAngle) {				startPeer = i;				minAngle = angle;			}		}		if (invertedSwarm)			startPeer = (nbPeers != 0) ? (startPeer + nbPeers / 2) % nbPeers : 0;		// System.out.println("rotY:" + (rotY * 180 / Math.PI) + ", nbPeers:"+		// nbPeers + ", peer:" + startPeer);		if (nbPeers != 0) {			for (int i = 0; i < nbPeers; i++) {				int peerNb = (i == 0) ? startPeer : (i % 2 == 0) ? (startPeer						+ nbPeers - i / 2)						% nbPeers : (startPeer + (i + 1) / 2) % nbPeers;				Peer peer = sortedPeers[peerNb];				ByteArrayWrapper peerId = utilities.createWrapper(peer.getId());				theta = (float) (2 * peerNb * Math.PI / nbPeers);				completion = peer.getPercentDoneInThousandNotation();				theta = movePeerSlowly(peer, peerId, theta, completion);				completion = drawPeerSlowly(peer, peerId, completion);				objects.add( new Object[]{ radius, theta, centerRadius, peerRadius, peer, completion });				if ((notDone) && (i >= nbPeers / 2)) {					notDone = false;					objects.add( new Object[]{ centerRadius });				}			}			rotY += rotYStep;		} else {			objects.add( new Object[]{ centerRadius });		}		return( objects );	}		private void 	renderSceneSupport(		List<Object[]> objects ) {		GL11.glClear(GL11.GL_COLOR_BUFFER_BIT | GL11.GL_DEPTH_BUFFER_BIT);		GL11.glLoadIdentity();		FloatBuffer fB = allocFloats(lightPosition);		GL11.glLight(GL11.GL_LIGHT0, GL11.GL_POSITION, fB);		GL11.glTranslatef(xPos, yPos, zPos);		for ( Object[] obj: objects ){						if ( obj.length == 1 ){						renderCenter((Float)obj[0]);						}else{								renderPeer( 						(Float)obj[0],(Float)obj[1],(Float)obj[2],(Float)obj[3],						(Peer)obj[4],(Integer)obj[5] );			}		}	}	private float movePeerSlowly(Peer peer, ByteArrayWrapper id, float theta,			int percentDone) {		PeerState lastState;		if (peerStates.containsKey(id)) {			lastState = (PeerState) peerStates.get(id);		} else {			lastState = new PeerState();			lastState.percentDone = percentDone;			lastState.theta = theta;		}		if (lastState.theta != theta) {			if (lastState.percentDone > 0) {				float diff = theta - lastState.theta;				if (diff > Math.PI) {					diff = -diff;				}				if (diff<0.001)					theta = lastState.theta + diff/14;				if (theta < 0) {					theta += 2 * Math.PI;				}				if (theta > 2 * Math.PI) {					theta -= 2 * Math.PI;				}			}		}		lastState.theta = theta;		lastState.percentDone = percentDone;		peerStates.put(id, lastState);		return theta;	}	private int drawPeerSlowly(Peer peer, ByteArrayWrapper id, int percentDone) {		PeerDisplay lastDisplay;		if (peerDisplayed.containsKey(id)) {			lastDisplay = (PeerDisplay) peerDisplayed.get(id);		} else {			lastDisplay = new PeerDisplay();			lastDisplay.percentDisplayed = percentDone;		}		if (lastDisplay.percentDisplayed < percentDone - 10) {			lastDisplay.percentDisplayed = lastDisplay.percentDisplayed + 10;		} else if (lastDisplay.percentDisplayed < percentDone) {			lastDisplay.percentDisplayed = percentDone;		}		peerDisplayed.put(id, lastDisplay);		return lastDisplay.percentDisplayed / 10;	}	private void renderCenter( float cR) {		GL11.glPushMatrix();		GL11.glRotatef(alphadeg, 1.0f, 0.0f, 0.0f);		int percentCompleted = TESTING?50:(download.getStats().getCompleted() / 10);		drawCylinder(cR, 1.0f, percentCompleted, 0);		setColorValues(0);		if (percentCompleted == 100) {			setColorValues(3);		}		if(alphadeg < 15.0f || alphadeg > 345.0f) {			disk = new Disk();			disk.draw( 0.0f, (float) percentCompleted / 100 * cR,					16, 1);						setColorValues(1);			disk = new Disk();			disk.draw( (float) percentCompleted / 100 * cR, cR,					16, 1);		} else {			setColorValues(1);			disk = new Disk();			disk.draw( 0.0f, cR,					16, 1);		}		GL11.glPopMatrix();	}	private void renderPeer(float radius, float theta, float centerRadius, float peerRadius,			Peer peer, int completion) {				if( peer.isSeed() && download.isComplete() ) {			return;		}				Connection connection = peer.getConnection();				if ( connection == null ){			return;		}				GL11.glPushMatrix();		GL11.glRotatef(alphadeg, 1.0f, 0.0f, 0.0f);		float x = (float) (-radius * Math.sin(theta + rotY));		float y = (float) (radius * Math.cos(theta + rotY));		GL11.glTranslatef(x, y, 0.0f);		drawCylinder(peerRadius, 0.8f, completion, peer.isSnubbed()?1:2);		//drawCylinder(peerRadius, 0.8f, completion, 2);		disk = new Disk();		disk.draw( 0.0f, peerRadius, 16, 1);		GL11.glTranslatef(0, 0, -0.8f);		if (!peer.isChoking() || !peer.isChoked()) {			drawLine(x, y, radius, centerRadius, peerRadius);		}		GL11.glPopMatrix();		GL11.glPushMatrix();				float w = 1.75f / nbPeers;		if(w>0.05f) w = 0.05f;				/*		 * Drawing Completion of a block sent BY the Peer (BLUE)		 */		int percentSent = connection.getIncomingMessageQueue()				.getPercentDoneOfCurrentMessage();		if (percentSent >= 0) {			//			double r1 = radius - 0.2d - 0.25d - (radius - 0.4d - 0.2d - 0.25d) * percentSent//					/ 100;						double r1 = radius - peerRadius - 5*w - (radius - centerRadius - peerRadius - 5*w) * percentSent			/ 100;			x = (float) (-r1 * Math.sin(theta + rotY));			y = (float) (r1 * Math.cos(theta + rotY));			GL11.glRotatef(alphadeg, 1.0f, 0.0f, 0.0f);			GL11.glTranslatef(x, y, 0.0f);			GL11.glRotatef(-90.0f, 1.0f, 0.0f, 0.0f);			GL11.glRotatef(-(theta + rotY) * 180 / (float) Math.PI, 0.0f, 1.0f,					0.0f);			drawPacket(peer.isSnubbed()?1:0,w);			//drawPacket(0);		}		GL11.glPopMatrix();		GL11.glPushMatrix();				/*		 * Drawing Completion of a block sent TO the Peer (RED)		 */		percentSent = connection.getOutgoingMessageQueue()				.getPercentDoneOfCurrentMessage();		if (percentSent >= 0) {			double r1 = centerRadius + (radius - centerRadius - peerRadius - 5*w) * percentSent					/ 100;			x = (float) (-r1 * Math.sin(theta + rotY));			y = (float) (r1 * Math.cos(theta + rotY));			GL11.glRotatef(alphadeg, 1.0f, 0.0f, 0.0f);			GL11.glTranslatef(x, y, 0.0f);			GL11.glRotatef(-90.0f, 1.0f, 0.0f, 0.0f);			GL11.glRotatef(-(theta + rotY) * 180 / (float) Math.PI, 0.0f, 1.0f,					0.0f);			drawPacket(peer.isSnubbed()?1:2,w);			//drawPacket(2);		}		GL11.glPopMatrix();	}	void drawLine(float x, float y, float radius, float centerRadius, float peerRadius) {		GL11.glBegin(GL11.GL_LINES);		float xp, yp,					xq, yq; 		xp = (float) (centerRadius / radius) * x;		yp = (float) (centerRadius / radius) * y;				xq = (float) (peerRadius / radius) * x;		yq = (float) (peerRadius / radius) * y;				GL11.glVertex3f(-xq, -yq, 0.0f);		GL11.glVertex3f(-x + xp, -y + yp, 0.0f);		GL11.glEnd();	}	/**	 * 	 * Sets the current color values into the rendered display.	 * 	 * 0 is blue	 * 	 * 1 is grey	 * 	 * 2 is red	 * 	 * 3 is green	 * 	 */	void setColorValues(int color) {						GL11.glLight(GL11.GL_LIGHT0, GL11.GL_DIFFUSE, fB[color][4]);		GL11.glMaterial(GL11.GL_FRONT_AND_BACK, GL11.GL_DIFFUSE, fB[color][4]);		GL11.glMaterial(GL11.GL_FRONT_AND_BACK, GL11.GL_AMBIENT, fB[color][5]);		GL11.glLight(GL11.GL_LIGHT0, GL11.GL_AMBIENT, fB[color][1]);			GL11.glLight(GL11.GL_LIGHT0, GL11.GL_SPECULAR, fB[color][2]);					GL11.glMaterial(GL11.GL_FRONT_AND_BACK, GL11.GL_SPECULAR, fB[color][6]);			GL11.glLightModel(GL11.GL_LIGHT_MODEL_AMBIENT, fB[color][3]);				GL11.glMaterialf(GL11.GL_FRONT_AND_BACK, GL11.GL_SHININESS, (float)materialShininess[color][0]);	}	    public static FloatBuffer allocFloats(float[] floatarray) {    	FloatBuffer fb = BufferUtils.createFloatBuffer(4);        fb.put(floatarray).flip();        return fb;    }	/**	 * 	 * Swaps the buffers.	 * 	 */	void swap() {		glCanvas.swapBuffers();	}	public void setDownload(Download download) {		synchronized (this) {			peerStates.clear();			peerDisplayed.clear();			this.download = download;		}	}		public static void	main(		String[]	args )	{		try{			TESTING = true;						final Display display = new Display();			Shell shell = new Shell(display);			shell.setLayout(new FillLayout());			Composite comp = new Composite(shell, SWT.NONE);			AzureusCore core = AzureusCoreFactory.create();									PluginInterface pi = core.getPluginManager().getDefaultPluginInterface();						HashMap params = new HashMap();						params.put( 0, "0" );			params.put( 1, "1" );						Peers3DGraphicView view = new Peers3DGraphicView( pi, comp, params );									shell.setText("3DView Tester");						shell.setSize(640, 480);			shell.open();						while (!shell.isDisposed()) {				if (!display.readAndDispatch())					display.sleep();			}			display.dispose();		}catch( Throwable e ){						e.printStackTrace();		}	}}